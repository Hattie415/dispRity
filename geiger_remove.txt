Fun: in dtt.dispRity_fun.R:

## This is the internal function modified from https://github.com/mwpennell/geiger-v2/blob/master/R/disparity.R; 
.ratematrix <- function(phy, data) {

    ## Equivalent to geiger::treedata(data, phy, sort = TRUE)
    td <- clean.data(data, phy)
    names(td)[1] <- "phy"
    ## Sort the data
    td$data <- td$data[td$phy$tip.label, ]
    ## Print some warnings (dropped things)
    if(!is.na(td$dropped_tips)) {
        warning(paste0("The following tips were not found in 'data' and were dropped from 'phy':\n", paste(td$dropped_tips, collapse = ", ")))
    }
    if(!is.na(td$dropped_rows)) {
        warning(paste0("The following rows were not found in 'phy' and were dropped from 'data':\n", paste(td$dropped_rows, collapse = ", ")))
    }

    f.pic <- function(x) pic(x, td$phy)

    ic <- apply(td$data, 2, function(x) {
                names(x)=rownames(td$data)
                pic(x, td$phy)
                })
    
    r <- crossprod(ic, ic)/nrow(ic)
    return(r)
}


Fun: in dtt.dispRity.R:


		## Replace geiger::ratematrix
        rate_matrix <- .ratematrix(tree, data)


        ## Replace geiger::sim.char
        ?replicate(rTraitCont, )
        ?rTraitCont(tree, model = "BM")
        ?ape::rTraitCont
        ?ape::rTraitDisc
        ?ape::rTraitMult
        ?phytools::sim.multiMk
        ?rTraitCont(phy, model = "BM", sigma = 0.1, alpha = 1, theta = 0, ancestor = FALSE, root.value = 0, ...)
















dispRity/tests/testthat/test-dtt.dispRity.R
    expect_equal(as.character(warn), "simpleWarning in treedata(phy, data): The following tips were not found in 'data' and were dropped from 'phy':\n\tolivacea\n")

dispRity/tests/testthat/test-plot.dispRity.R
    expect_warning(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 2))
    expect_null(plot(dispRity_dtt, quantiles = c(0.1, 0.95)))
    expect_error(plot(dispRity_dtt, quantiles = c(10, 110)))
    expect_error(plot(dispRity_dtt, cent.tend = var))

dispRity/tests/testthat/test-print.dispRity.R
test_that("dtt printing", {
    ## The average squared pairwise distance metric (used in geiger::dtt)
    ## Calculate the disparity of the dataset using dtt.dispRity
    dispRity_dtt <- dtt.dispRity(data = data, metric = average.sq,
    print_dtt <- capture.output(dispRity_dtt)
    expect_equal(print_dtt,
        "Disparity-through-time test (modified from geiger:dtt)" ,
        "Call: dtt.dispRity(data = data, metric = average.sq, tree = tree, nsim = 10, model = \"BM\", alternative = \"two-sided\") ",
        "    Mean.dtt Mean.sim_MDI  var.sim_MDI ",
    dispRity_dtt_raw <- dtt.dispRity(data = data, metric = average.sq,
    print_dtt_raw <- capture.output(dispRity_dtt_raw)
    expect_equal(print_dtt_raw[c(11,12)],
        # "$dtt"                                                                                      ,
        "- attr(*, \"class\") = \"dispRity\" \"dtt\""   

dispRity/tests/testthat/test-dtt.dispRity.R
#TESTING dtt.dispRity
context("dtt.dispRity")
test_that("dispRity and dtt give the same results", {
    ## Calculate the disparity of the dataset using dtt::geiger
    warn <- capture_warning(geiger::dtt(phy = geiger_data$phy, data = geiger_data$dat, nsim = 100, plot = FALSE, calculateMDIp = TRUE))
    expect_warning(geiger_dtt <- geiger::dtt(phy = geiger_data$phy, data = geiger_data$dat, nsim = 100, plot = FALSE, calculateMDIp = TRUE))
    ## The average squared pairwise distance metric (used in geiger::dtt)
    ## Calculate the disparity of the dataset using dtt.dispRity
    expect_warning(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100))
    plot(dispRity_dtt)
    expect_error(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = var, tree = geiger_data$phy, nsim = 100))
    expect_error(dtt.dispRity(data = disparity, metric = var, tree = BeckLee_tree, nsim = 10))
    error <- capture_error(dtt.dispRity(data = geiger_data$dat, metric = var, tree = geiger_data$phy, nsim = 100))
    test <- dtt.dispRity(data = BeckLee_mat50, metric = c(sum, variances), tree = BeckLee_tree, nsim = 2)
    expect_is(test, c("dispRity", "dtt"))
    expect_equal(length(geiger_dtt)+2, length(dispRity_dtt))
    expect_equal(unlist(lapply(geiger_dtt[-5], length)), unlist(lapply(dispRity_dtt[-c(5,6,7)], length)))
    # expect_warning(dtt_data <- dtt.dispRity(data = disparity, metric = average.sq, tree = BeckLee_tree, nsim = 5))
    # expect_is(dtt_data, "dispRity", "dtt")
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "two-sided")
    expect_equal(dispRity_dtt$p_value, 0.84)
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "lesser")
    expect_equal(dispRity_dtt$p_value, 0.54)
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "greater")
    expect_equal(dispRity_dtt$p_value, 0.46)
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 0)
    expect_is(dispRity_dtt, c("dispRity", "dtt"))
    expect_equal(names(dispRity_dtt), c("dtt", "times"))

dispRity/tests/testthat/test-plot.dispRity.R
    ## Loading geiger's example data set
    require(geiger)
    geiger_data <- get(data(geospiza))
    expect_warning(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 2))

dispRity/tests/testthat/test-print.dispRity.R
    ## Loading geiger's example data set
    ## The average squared pairwise distance metric (used in geiger::dtt)
        "Disparity-through-time test (modified from geiger:dtt)" ,
        
        
dispRity/tests/testthat/test-dtt.dispRity.R
    library(geiger)
        geiger::disparity(data = geo$dat, index = "avg.sq")
        geiger_disp <- geiger::disparity(phy = geo$phy, data = geo$dat, index = "avg.sq")
    expect_equal(as.vector(geiger_disp), as.vector(dispRity_disp))
    geiger_data <- get(data(geospiza))
    ## Calculate the disparity of the dataset using dtt::geiger
    warn <- capture_warning(geiger::dtt(phy = geiger_data$phy, data = geiger_data$dat, nsim = 100, plot = FALSE, calculateMDIp = TRUE))
    expect_warning(geiger_dtt <- geiger::dtt(phy = geiger_data$phy, data = geiger_data$dat, nsim = 100, plot = FALSE, calculateMDIp = TRUE))
    ## The average squared pairwise distance metric (used in geiger::dtt)
    expect_warning(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100))
    expect_error(dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = var, tree = geiger_data$phy, nsim = 100))
    error <- capture_error(dtt.dispRity(data = geiger_data$dat, metric = var, tree = geiger_data$phy, nsim = 100))
    expect_equal(length(geiger_dtt)+2, length(dispRity_dtt))
    expect_equal(unlist(lapply(geiger_dtt[-5], length)), unlist(lapply(dispRity_dtt[-c(5,6,7)], length)))
    geiger_data$phy <- drop.tip(geiger_data$phy, "olivacea")
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "two-sided")
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "lesser")
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 100, alternative = "greater")
    dispRity_dtt <- dtt.dispRity(data = geiger_data$dat, metric = average.sq, tree = geiger_data$phy, nsim = 0)